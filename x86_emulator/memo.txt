1.
・私たちが普段書いているコードはテキストファイル
・コードはASCIIコードやUTF-8など指定された文字コードで16進数に変換される（字句解析）
・アセンブリ言語は機械語と1対1で対応している
・そのため、機械語を直接読む代わりにアセンブリ言語に変換してから読むことが多い
・アセンブリ言語のプログラムは「オペコード　オペランド1, オペランド2」という形をとる
・movはコピーをするためのオペコードで、メモリアドレスにレジスタ（ebpやespなど）の値を書き込む


memo
・32ビットと64ビットの違いは、レジスタとメモリアドレスの幅である
・CPUエミュレータ（QEMUなど）は、ゲスト（x86_64）の機械語をホスト（Arm64）の機械語に変換して実行している
・ハードウェア（I/O）もホストのOSリソースにマッピングすることで、OS全体を丸ごと動かしている


2.
メモリ
・CPUはメモリ番地を指定して、レジスタにデータをセットする
・アセンブリではレジスタでデータの場所を指定するが、C言語ではレジスタを直接指定する代わりに「変数」で指定する
・レジスタはeax, ebpのように名前で指定するのに対し、メモリは[ebp-4]のように番地を使って指定する
・メモリ領域は、コード（テキスト）領域、データ領域、ヒープ領域、スタック領域の4つに分かれている
・スタック領域はアドレスが大きい方から小さい方に向かって「成長」する
・プログラムの場所を指定するのがeipであり、メモリのコード領域にある機械語命令を順に指し示す
・処理中の一時的なデータ（引数、ローカル変数）を指定するのがespやebpであり、スタック領域にあるデータを順に指し示す

変数
・C言語では変数がレジスタではなくメモリに置かれている
・すべての変数はその変数が置かれたメモリ番地を持つ

ポインタ
・ポインタはメモリ番地と、指し示す先の領域の大きさを組み合わせた概念（例えば、int * はint型へのポインタを表す）
・メモリに名前をつけたものが「変数」である（例えば、ebp-4に"val"という名前を付け人間にわかりやすくしている）
・ポインタ変数とint型変数は、番地を書き込むか整数を書き込むかの違いがあるだけで、どちらも変数（名前がついやメモリ領域）であることに変わりない
・例えるなら、郵便番号がメモリ番地、住所が変数。両方同じ場所（メモリ上の場所）を指していることに変わりない
・ポインタ変数はメモリ番地（郵便番号）で指定する。変数は変数名（住所）で指定する。どちらも同じメモリの場所を指している
・val：[ebp-4], *p：0x000000FF
・CPUはメモリ番地を見てアクセスする

構造体
・構造体は、複数の変数をまとめて新しい型（ユーザ定義型）を作る機能
・構造体が含む各変数をメンバ変数と呼ぶ
・各メンバ変数は構造体の中で順番に並び、構造体先頭からのオフセット位置が決まっている
・構造体のポインタ変数pに格納されるのは構造体先頭のメモリ番地だが、->で参照外しをすると、pに格納された番地にそのメンバのオフセットを加算した番地を読み書きできる

型
・ある型の変数を定義するときは、その型の大きさがわかっている必要がある
・なぜなら、大きさがわからないと、コンパイラがどれほどのメモリを割り当てるか判断できない
・struct [構造体名] とすることで、構造体の中身を書かずに構造体を宣言できる
・ポインタは指す先の中身に関係なく常に一定（32ビットCPUなら4バイト）
・構造体の中身を読み書きするには必ず関数を使い、それらの関数に構造体のポインタを渡すようにすれば、構造体の詳細が必要なのは関数内部に限定される（カプセル化）
・こうすることで、構造体の実装を変更しても、その変更によりコードを再コンパイルする必要がなくなる
・つまり、main.cではなくuser.c側で構造体のメモリ領域の大きさを定義しているため、user.cだけ際コンパイルすればいい

CPUエミュレータ
・エミュレータの構成部品はレジスタとメモリ
・今回のプロジェクトでは、CPUの動作を模倣するために、レジスタとメモリを再現している
・つまり、main.cはCPU（エミュレータ）の動作を再現するプログラムであり、メモリとレジスタ、CPUが使用する命令実装することで、CPUの動作そのものを再現している
・CPU、メモリ、レジスタなどを物理的に再現するのは難しいが、動きを知りたいだけならC言語のプログラムで論理的に動きを再現できる

・サブルーチンは複数のアセンブリ命令をまとめた、なんらかの機能を持つかたまり
・アセンブリ言語のサブルーチンに、引数と戻り値を付け足したものが関数
・関数ポインタはtypedefで関数の型を定義して使うのが一般的

memo
・ポインタ変数は値としてメモリ番地を格納するため、何型であってもポインタ変数自身の大きさは同じになる（面積がばらばらな複数の地域でも、7桁の郵便番号で指し示せるのと似ている）
・アセンブリでは、変数valを[ebp-4]と表現していた。

3.
・CPUは内蔵するプログラムカウンタ（eipレジスタ）が指すメモリ領域から機械語命令を読み取って解釈し、その命令に従って動作する
・CPUはメモリに置いてあるプログラムしか実行できない
・CPUに実行してほしいプログラムは最初に不揮発性の記憶装置（HDDやSSDなどの補助記憶装置）に書き込んでおき、適宜メインメモリへ読み出すようにする

プログラムローダ
・補助記憶装置に書き込んでおいたCPUが実行するための機械語プログラム（実行可能ファイル）はプログラムローダによってメモリに読み出される
・その後、プログラムローダは読み出したプログラムの先頭へジャンプし、目的のプログラムが実行される

BIOS
・BIOSがプログラムローダをメモリに読み出す
・パソコンの電源を入れると、CPUはBIOSに書かれたプログラムを実行する
・BIOSには、HDDからOSを探し出してメモリ上に読み出し、そこへジャンプするプログラムがあらかじめ書き込まれている
・0x7c00はBIOSが補助記憶装置のMBRから読み出したプログラムを配置する標準的な番地
・したがって、このプログラムをアセンブルしてMBRに書き込み、パソコンを起動させれば、OSに力を借りずにプログラムを実行できる

機械語プログラム
・機械語プログラムはさまざまな形式で補助記憶装置に格納される
・Raw Binary：補助記憶装置のMBR（Master Boot Record）という特殊な領域に書き込むのに使う
・PE（Windows）, Mach-O（Mac）, ELF（Unix）：機械語のバイト列にヘッダを付与したファイル
・どの実行可能ファイルの形式であっても、基本的にはメモリの特定の番地に配置する必要がある

CPU
・メインメモリから命令を読み込む「フェッチ」、命令を解釈する「デコード」、そして最後の「実行」
・CPUは、内蔵するレジスタや加算器、論理演算器など使い、これらの一連の過程をずっとくり返す
・CPUはアドレスバストデータバスを介してメモリや周辺機器とデータのやり取りをする
・フェッチはeipレジスタに格納された番地のメモリ領域から機械語命令のバイト列を読み取る
・デコードは機械語命令から、実際のCPU内部の回路を制御する信号を作り出す
・例えばadd eax, 1をデコードすると、eaxレジスタの出力側と即値の1を加算機に接続する信号と、加算機の出力をeaxレジスタの入力側に接続する信号などを生成する
・実行は最後に回路を動作させ、演算したりメモリを読み書きしたりする
・add eax, 1の例では、加算機で計算された結果がeaxレジスタに書き込まれる
（p86に機械語命令のフェッチについて具体例が示されている）

機械語命令の構造
・機械語命令は、[プレフィックス, オペコード, ModR/M, SIB, ディスプレースメント, イミディエイト]のような構造になっている
・ModR/Mはメモリ番地を柔軟に指定するための1バイト
・例えば、inc [ebp-4]の場合、ff 45 fc という機械語に変換され、オペコードがff、Mod/R/Mが45, ディスプレースメントがfcとなる
・オペコードの仕様から、他のフィールドに何がセットされるか決まる
・SIBはModR.Mと組み合わせてさらに複雑な番地指定をするための1バイト
https://www.info.kochi-tech.ac.jp/y-takata/pl2/part1/handasm.html

jmp命令
・jmpは最も単純な分岐命令（if）で、オペランドに指定したメモリ番地をeipに書き込む（加算する）ことで任意の番地にジャンプする
・jmp命令が実行されると必ずeipが書き変わってジャンプするため、無条件分岐命令とも呼ぶ
・jmpはeipに値を入れるだけでなく、高速化のために先読みした命令を捨てるという重要な役割がある
・CPUは動作の高速化のために「パイプライン」という仕組みを持っていて、ある命令を実行するときにはすでになんん命令も先の命令をフェッチしたりデコードしたりしている
・jmp命令を実行するとeipの値が変わってしまうため、元の値を当てにして先読みしていたメモリの値やデコードが済んで一時t形にためてある命令を捨てなければならない（パイプラインのフラッシュ）
・そのため、if,for,while文などには、条件分岐命令（js）と比較命令（CMP）を組み合わせる

スタック
・x86アーキテクチャでは、メモリの一部をスタック構造として使う
・x86 CPUにはesp（スタックポインタ）というレジスタがあり、これがスタックの先頭番地を保持する役目を持つ
・命令はpushとpopの2種類
・push：espを4だけ減少させる → espが指すメモリ領域にオペランドを書き込む
・pop：espが指すメモリ領域から値を読み取ってオペランドに書き込む → espを4だけ増加させる
・スタックはプッシュするたびに大きくなり、ポップせずにプッシュし続けるとやがて破壊してはいけないメモリ領域まで到達してしまう（スタックオーバーフロー）

call/ret命令
・サブルーチンを呼び出したり、サブルーチンから元の場所に戻る命令
・callはメモリのとある場所に実行中のメモリ番地をメモしてからサブルーチンにジャンプし
・retはメモした値を取り出して元の場所に戻る
・番地をメモするのに使う場所がスタック

スタックフレーム
・関数を1回呼び出すごとに、引数用域、戻り番地、ebpの保存領域、ローカル変数領域からなる大きなメモリ領域が生成される。この領域をスタックフレームと呼ぶ
・スタックフレームは関数呼び出しが起こるとスタックに積まれ、関数が終了するとスタックから取り除かれる
・関数の初めにebpを保存しておくとスタックフレームの破棄が簡単になる
・スタックポインタは、CPUが現在使用しているスタック領域の最上位のアドレスを指し示す特殊レジスタ

戻り値
・C言語では引数はいくつでも渡せるのに対し、戻り値は高々1つと決まっている
・戻り値に使われるレジスタはeaxに決まっており、関数からretで戻ってきたときにeaxに入っている値が戻り値であるというルールになっている

js/cmp命令
・条件分岐命令はeflags（フラグレジスタ）の各フラグの状態に応じて、ジャンプするかしないかが決まるジャンプ命令
・各フラグの状態とは、CF（繰り上がり/繰り下がりフラグ）、ZF（ゼロフラグ）、SF（符号フラグ）、OF（オーバーフローフラグ）の4つ
・subを使えば条件分岐命令の条件は簡単に書けるが、subはオペランドを変更してしまうという欠点がある
・cmpはsubと同じように計算を行い、同じようにフラグを設定するが、オペランドを変更しない点がsubと異なる
・X>Yが成り立つかを調べたければX-Yの結果を調べれば十分なので、引き算にcmpという名前をつけて代償関係を比べる命令として使っている

I/Oポート
・CPUと入出力装置（キーボード、ディスプレイなど）は、I/Oポートと呼ばれる部品を介して接続されている
・CPUからはアドレスバスとデータバスがI/Oポートの片側に接続され、もう片側にはたくさんの装置のアドレスバストデータバスが接続されている
・I/Oマップは入出力装置が何番地に接続されているかを示す（多くのシステムではメモリ空間の一部を使用するメモリマップドI/Oが使われている）
・I/Oポートのアドレスバスは、一般的なx86アーキテクチャのコンピュータの場合は16ビットの幅があり、CPUは0x0000~0xffffまでの領域を読み書きできる
・読み書きにはメモリの読み書きに使うmovではなく、in, outというI/Oポートの読み書き専用の命令を使う
・HDDやUSBメモリからファイルを読み込んだりインターネットに接続できるのもI/Oポートのおかげ


memo
・C言語プログラムはまず.cファイルを1つずつコンパイルして.oファイルに変換した後、すべての.oファイルをリンクして1つの.exeファイルを作る
・即値は、命令の末尾付近に配置される演算に使われるデータ
（例: add, eax, 8 ← 即値 | mov, eax, [ebp+8]）
・機械語命令の構造についてはp83を参照
・ModR/Mの仕様についてはp85の表3.6を参照
・コンパイラはなるべくアライメントを揃えるように調整した機械語を作り出そうとする
・アライメントとは、複数バイトにまたがるような変数をCPUに都合のいいメモリ番地に配置すること（データバス幅が32ビットの場合、4バイトを一度に読み書きできるため、それ以外の場所に置くよりプログラムが高速に動く）
・espはスタックの先頭を指す（スタック領域内の一番上）。ebpはスタック上の何らかのデータを指す（テキスト領域に書かれたメモリアドレスをスタック領域内で扱うために変数的に指定する）
・電源入れる→CPUがBIOSに書かれたプログラムを実行する→BIOSはHDDからOSを探し出してメモリ上に読み出し、そこにジャンプする（0x7C00）
・プログラムローダはOSの一部としてHDDに格納されている。補助記憶装置に書き込んでいたCPUが実行するための機械語プログラム（実行可能ファイル）は、プログラムローダによってメモリ（テキスト領域）に読み出される
・dxはedxレジスタの下位16ビット


4.
BIOS
・CPUからBIOSを呼び出すには、必要なレジスタに値を設定してからint命令を実行する
・intのオペランドとahレジスタの値の組み合わせでBIOSが持つ機能群の中のどれを呼び出すかを選択する
・int命令は割り込みを発生させる命令で、int N とかいてN番目のサブルーチンをcallする
・Nには0x00から0xffまでの256種類の番号を指定することができて、それぞれの番号に応じたサブルーチンが呼び出される

割り込み
・プログラムを実行中のCPUに割り込んで他のプログラムを実行させる機能
・割り込み処理用のサブルーチンを用意しておくと、CPUが割り込み要求信号を受信したときにそのサブルーチンを実行してくれる
・ちょうど、家で本を読んでいるときにインターホンが鳴り（CPUが割り込み要求を受信する）、お客様の対応をする（お客対応用サブルーチンを呼び出す）ようなもの
・対応が終わればまた読書を再開するように、CPUもサブルーチンの実行が終われば元のプログラムの続きを実行する
・CPUは1つの命令を実行するたびに割り込み要求がきているかを確認する
・要求がきていれば、現在の作業を後で再開できるようにスタックにflagsの内容を保存し、サブルーチンを呼びだす
・callによる普通の呼び出しとは違い、割り込みはいつ発生するかわからない

割り込みハンドラ
・割り込みで使うサブルーチンは、普通のものとは違い、いつ呼び出されるかわからないことを前提に処理を書く必要がある
・基本的に全てのレジスタの値はサブルーチンの呼び出し前後で保持されていなければならない（ここはプログラマの責任範囲）
・処理を終えて呼び出し元に戻るのにretではなくiretを使う。iretはflagsの復元も行う
・割り込み用のサブルーチンは一般に「割り込みハンドラ」と呼ばれる

割り込みベクタテーブル
・割り込み発生時に呼び出されるサブルーチンを指定するために、サブルーチンの先頭アドレスを登録しておくための特別なメモリ領域がある
・メモリの先頭から1024バイト、0x0000から0x03ffまでの領域を割引ベクタテーブル（IVT）と呼ぶ
・cs（セグメンテーション関連）とip（eipの下位16ビット）の組を256個登録しておくことができる
・割り込みにはタイマーのタイムアップやキーボード入力などの種類が256種類あって、それぞれに対応したハンドラを登録しておける仕組み
・何番目のハンドラが何の割り込みに対応するかは、割り込みコントローラという装置の設定によって変わる

HDD
・HDDはブロックデバイスといって、512バイトまたは4096バイト単位でデータを管理している
・この1ブロックを「物理セクタ」と呼び、物理セクタごとにデータを読み書きする仕組みになっている
・メモリは1バイト単位でデータを読み書きできたが、HDDはセクタ単位でしか読み書きできない
・物理セクタの大きさが512バイトか4096バイトかに関わらず、HDDを使う側は512バイト固定の「論理セクタ」で場所を指定することになっている
・HDDは表面に磁性体を塗った円盤（プラッタ）とデータを読み書きするための磁気ヘッドから構成されている
・プラッタが高速に回転しながら磁気ヘッドの先端にある電磁石でN極S極を読み書きする（p166）
・ブラッタ1周をトラック、全てのプラッタの同じ位置のトラックをまとめたものをシリンダ
・トラックは扇形のセクタに分割され、そのセクタには1から連番が振られている

ブートセクタ
・BIOSは入出力装置の制御の他に、起動デバイスから起動プログラムをメモリに読み出すという役割がある
・一般に、コンピュータには複数の起動デバイスが接続されている（HDD、USBメモリなど）
・BIOSは複数の起動可能なデバイスから、事前に設定された優先順位に従って起動に使うものを選択し、そこに書き込まれた起動プログラムをメモリに読みだす
・あるデバイスが起動かどうか調べるのに、BIOSはそのデバイスの先頭セクタ（論理セクタ）を調べる
・そのセクタの最後の2バイト（セクタの先頭を0番地とすると、510, 511番地）に0x55, 0xaaが書き込まれていたら、BIOSはそのデバイスが起動可能だと判断する
・優先度の高いデバイスから調べていって、最初に見つけた起動可能デバイスの先頭セクタをメモリの0x7c00から始まる512バイトの領域にコピーする
・つまり、HDDの先頭510バイトに機械語プログラムを書き、最後の2バイトに0x55, 0xaaを書き込んでおけば、パソコンの電源を入れた直後にそのプログラムを実行させることができる
・ブロックデバイスの先頭セクタは一般にブートセクタと呼ばれている

MBR
・複数のパーティションを持つHDDのような機器のブートセクタをMBR
・フロッピーディスクやUSBメモリなど1つのパーティションしか持たない機器のブートセクタをPBRと呼ぶこともある
・MBRは512バイトのうち、先頭446は機械語を書き込む領域で、その後にパーティションテーブルが続く
・テーブルは4つのパーティション情報を持ち、各テーブルは16バイトでp165のような構造になっている
・起動プログラムはパーティションテーブルを調べ、起動可能フラグが0x80になっているパーティションを探し、そのパーティションの内容を読み込んで起動するのが主な役割

LBA
・HDDの中でセクタを特定するための番号を振る方法に、CHS方式とLBA方式がある
・いまでは実質的にLBAしか使われていない
・LBAは先頭セクタを0とした通し番号
・パーティションテーブルには32ビットでLBAを設定できるので、512バイト×2^32=2TBまでのセクタを指定できる
・CHSではシリンダ番号とヘッド番号とセクタ番号があれば、HDDの中で特定のセクタを指定できる


memo
・siはesiレジスタの下位16ビット
・mov bx, 15は、mov bh, 0とmov bl, 15を同時に行う命令
・mov al,[si]は、SIレジスタが指しているメモリのアドレスから1バイト（8ビット）のデータを読み出し、そのデータをALレジスタに格納する
・I/Oの機能を実装し、0x03f8番のポートに1バイト出力すると、それがそのまま画面に出力されるようになっている
・リアルモードでの割り込みなので、eflagsではなくflagsを使っている
・pushaはax, cx, dx,bx, sp, bp, si, diをこの順番でスタックにプッシュし
・popaはその逆順でスタックからポップする、非常に便利な命令
・汎用レジスタの保存と復元がたった2命令で実現できる
・USBのPartition0は、ユーザーデータとは別の特殊な領域として扱われる