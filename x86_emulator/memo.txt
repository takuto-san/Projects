1.
・私たちが普段書いているコードはテキストファイル
・コードはASCIIコードやUTF-8など指定された文字コードで16進数に変換される（字句解析）
・アセンブリ言語は機械語と1対1で対応している
・そのため、機械語を直接読む代わりにアセンブリ言語に変換してから読むことが多い
・アセンブリ言語のプログラムは「オペコード　オペランド1, オペランド2」という形をとる
・movはコピーをするためのオペコードで、メモリアドレスにレジスタ（ebpやespなど）の値を書き込む


memo
・32ビットと64ビットの違いは、レジスタとメモリアドレスの幅である
・CPUエミュレータ（QEMUなど）は、ゲスト（x86_64）の機械語をホスト（Arm64）の機械語に変換して実行している
・ハードウェア（I/O）もホストのOSリソースにマッピングすることで、OS全体を丸ごと動かしている


2.
・CPUはメモリ番地を指定して、レジスタにデータをセットする
・アセンブリではレジスタでデータの場所を指定するが、C言語ではレジスタを直接指定する代わりに「変数」で指定する
・レジスタはeax, ebpのように名前で指定するのに対し、メモリは[ebp-4]のように番地を使って指定する

変数
・C言語では変数がレジスタではなくメモリに置かれている
・すべての変数はその変数が置かれたメモリ番地を持つ

ポインタ
・ポインタはメモリ番地と、指し示す先の領域の大きさを組み合わせた概念（例えば、int * はint型へのポインタを表す）
・メモリに名前をつけたものが「変数」である（例えば、ebp-4に"val"という名前を付け人間にわかりやすくしている）
・ポインタ変数とint型変数は、番地を書き込むか整数を書き込むかの違いがあるだけで、どちらも変数（名前がついやメモリ領域）であることに変わりない
・例えるなら、郵便番号がメモリ番地、住所が変数。両方同じ場所（メモリ上の場所）を指していることに変わりない
・ポインタ変数はメモリ番地（郵便番号）で指定する。変数は変数名（住所）で指定する。どちらも同じメモリの場所を指している
・val：[ebp-4], *p：0x000000FF
・CPUはメモリ番地を見てアクセスする

構造体
・構造体は、複数の変数をまとめて新しい型（ユーザ定義型）を作る機能
・構造体が含む各変数をメンバ変数と呼ぶ
・各メンバ変数は構造体の中で順番に並び、構造体先頭からのオフセット位置が決まっている
・構造体のポインタ変数pに格納されるのは構造体先頭のメモリ番地だが、->で参照外しをすると、pに格納された番地にそのメンバのオフセットを加算した番地を読み書きできる

型
・ある型の変数を定義するときは、その型の大きさがわかっている必要がある
・なぜなら、大きさがわからないと、コンパイラがどれほどのメモリを割り当てるか判断できない
・struct [構造体名] とすることで、構造体の中身を書かずに構造体を宣言できる
・ポインタは指す先の中身に関係なく常に一定（32ビットCPUなら4バイト）
・構造体の中身を読み書きするには必ず関数を使い、それらの関数に構造体のポインタを渡すようにすれば、構造体の詳細が必要なのは関数内部に限定される（カプセル化）
・こうすることで、構造体の実装を変更しても、その変更によりコードを再コンパイルする必要がなくなる
・つまり、main.cではなくuser.c側で構造体のメモリ領域の大きさを定義しているため、user.cだけ際コンパイルすればいい

CPUエミュレータ
・エミュレータの構成部品はレジスタとメモリ
・今回のプロジェクトでは、CPUの動作を模倣するために、レジスタとメモリを再現している
・つまり、main.cはCPU（エミュレータ）の動作を再現するプログラムであり、メモリとレジスタ、CPUが使用する命令実装することで、CPUの動作そのものを再現している
・CPU、メモリ、レジスタなどを物理的に再現するのは難しいが、動きを知りたいだけならC言語のプログラムで論理的に動きを再現できる

・サブルーチンは複数のアセンブリ命令をまとめた、なんらかの機能を持つかたまり
・アセンブリ言語のサブルーチンに、引数と戻り値を付け足したものが関数
・関数ポインタはtypedefで関数の型を定義して使うのが一般的

memo
・ポインタ変数は値としてメモリ番地を格納するため、何型であってもポインタ変数自身の大きさは同じになる（面積がばらばらな複数の地域でも、7桁の郵便番号で指し示せるのと似ている）
・アセンブリでは、変数valを[ebp-4]と表現していた。

3.
・CPUは内蔵するプログラムカウンタ（eipレジスタ）が指すメモリ領域から機械語命令を読み取って解釈し、その命令に従って動作する
・CPUはメモリに置いてあるプログラムしか実行できない
・CPUに実行してほしいプログラムは最初に不揮発性の記憶装置（HDDやSSDなどの補助記憶装置）に書き込んでおき、適宜メインメモリへ読み出すようにする

プログラムローダ
・補助記憶装置に書き込んでおいたCPUが実行するための機械語プログラム（実行可能ファイル）はプログラムローダによってメモリに読み出される
・その後、プログラムローダは読み出したプログラムの先頭へジャンプし、目的のプログラムが実行される

BIOS
・BIOSがプログラムローダをメモリに読み出す
・パソコンの電源を入れると、CPUはBIOSに書かれたプログラムを実行する
・BIOSには、HDDからOSを探し出してメモリ上に読み出し、そこへジャンプするプログラムがあらかじめ書き込まれている
・0x7c00はBIOSが補助記憶装置のMBRから読み出したプログラムを配置する標準的な番地
・したがって、このプログラムをアセンブルしてMBRに書き込み、パソコンを起動させれば、OSに力を借りずにプログラムを実行できる

機械語プログラム
・機械語プログラムはさまざまな形式で補助記憶装置に格納される
・Raw Binary：補助記憶装置のMBR（Master Boot Record）という特殊な領域に書き込むのに使う
・PE（Windows）, Mach-O（Mac）, ELF（Unix）：機械語のバイト列にヘッダを付与したファイル
・どの実行可能ファイルの形式であっても、基本的にはメモリの特定の番地に配置する必要がある

CPU
・メインメモリから命令を読み込む「フェッチ」、命令を解釈する「デコード」、そして最後の「実行」
・CPUは、内蔵するレジスタや加算器、論理演算器など使い、これらの一連の過程をずっとくり返す
・CPUはアドレスバストデータバスを介してメモリや周辺機器とデータのやり取りをする
・フェッチはeipレジスタに格納された番地のメモリ領域から機械語命令のバイト列を読み取る
・デコードは機械語命令から、実際のCPU内部の回路を制御する信号を作り出す
・例えばadd eax, 1をデコードすると、eaxレジスタの出力側と即値の1を加算機に接続する信号と、加算機の出力をeaxレジスタの入力側に接続する信号などを生成する
・実行は最後に回路を動作させ、演算したりメモリを読み書きしたりする
・add eax, 1の例では、加算機で計算された結果がeaxレジスタに書き込まれる
（p86に機械語命令のフェッチについて具体例が示されている）
